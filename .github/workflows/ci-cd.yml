name: CI/CD Pipeline

on:
  push:
    branches: ["dev"]

permissions:
  contents: write
  actions: read
  checks: write
  pull-requests: write

jobs:
  build-test:
    runs-on: ubuntu-latest

    services:
      db_test:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: admin
          POSTGRES_DB: inventario_db_test
        ports:
          - 5433:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      SPRING_PROFILES_ACTIVE: test
      SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5433/inventario_db_test
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: admin
      APPLICATION_SECURITY_JWT_SECRET_KEY: 404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Make gradlew executable
        run: chmod +x gradlew

      - name: Wait for PostgreSQL (db_test)
        run: |
          until pg_isready -h localhost -p 5433 -U postgres; do
            echo "Esperando a db_test..."
            sleep 2
          done

      - name: Run Flyway migrations (test)
        run: ./gradlew flywayMigrate -PflywayUrl=jdbc:postgresql://localhost:5433/inventario_db_test -PflywayUser=postgres -PflywayPassword=admin

      - name: Build application
        run: ./gradlew clean build -x test

      - name: Run Technical Regression (Fast)
        run: ./gradlew regressionTest

      - name: Run User Flows Regression
        run: ./gradlew cucumberTest
        continue-on-error: true

      - name: Guardar reportes JUnit como artefacto
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: reportes-junit
          path: |
            build/reports/tests/regressionTest/index.html
            build/reports/tests/unitTest/index.html
          retention-days: 30

      - name: Guardar reportes Cucumber como artefacto
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: reportes-cucumber
          path: |
            build/reports/tests/cucumberTest/index.html
            build/reports/cucumber-report.html
          retention-days: 30

      - name: Guardar logs de pruebas (en caso de fallo)
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: logs-pruebas
          path: |
            build/reports/
            *.log

  stress-test:
    runs-on: ubuntu-latest
    needs: build-test

    steps:
      - name: Checkout código
        uses: actions/checkout@v4

      - name: Descargar y configurar JMeter
        run: |
          wget https://downloads.apache.org/jmeter/binaries/apache-jmeter-5.6.3.tgz
          tar -xzf apache-jmeter-5.6.3.tgz

      - name: Iniciar servicios con Docker Compose
        run: |
          docker compose -f docker-compose.yml up -d

      - name: Verificar estado de contenedores
        run: |
          echo "=== Estado de contenedores ==="
          docker compose ps
          echo ""
          echo "=== Logs de la base de datos ==="
          docker compose logs db
          echo ""
          echo "=== Logs de la aplicación ==="
          docker compose logs app

      - name: Esperar y verificar conectividad
        run: |
          echo "Esperando a que la app esté disponible..."
          
          # Verificar que la BD esté lista
          echo "Verificando PostgreSQL..."
          for i in {1..30}; do
            if docker compose exec -T db pg_isready -U postgres; then
              echo "PostgreSQL está listo"
              break
            fi
            echo "Esperando PostgreSQL... Intento $i de 30"
            sleep 5
          done
          
          # Dar tiempo adicional para que la app se conecte a la BD
          echo "Dando tiempo para que la app se conecte a la BD..."
          sleep 30
          
          # Verificar logs de la aplicación nuevamente
          echo "=== Logs recientes de la aplicación ==="
          docker compose logs --tail=50 app
          
          # Intentar conectarse a la aplicación
          for i in {1..60}; do
            echo "Intento $i de 60 - Verificando aplicación..."
          
            # Primero verificar que el contenedor esté corriendo
            if ! docker compose ps app | grep -q "Up"; then
              echo "El contenedor de la aplicación no está corriendo"
              docker compose logs app
              exit 1
            fi
          
            # Verificar conectividad básica al puerto
            if nc -z localhost 8080; then
              echo "Puerto 8080 está abierto"
          
              # Intentar el endpoint de login
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:8080/api/auth/login \
                -H "Content-Type: application/json" \
                -d '{"email": "admin@example.com", "password": "admin"}' || echo "000")
          
              echo "Código de respuesta del login: $HTTP_CODE"
          
              if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "400" ] || [ "$HTTP_CODE" = "401" ]; then
                echo "Aplicación está respondiendo"
                break
              fi
            else
              echo "Puerto 8080 no está disponible"
            fi
          
            if [ $i -eq 60 ]; then
              echo "La aplicación no respondió después de 10 minutos"
              echo "=== Logs finales de la aplicación ==="
              docker compose logs app
              echo "=== Estado final de contenedores ==="
              docker compose ps
              exit 1
            fi
          
            sleep 10
          done

      - name: Ejecutar prueba de estrés con JMeter
        run: |
          mkdir -p jmeter/reporte-html
          apache-jmeter-5.6.3/bin/jmeter \
            -n \
            -t jmeter/Inventario_testplan.jmx \
            -l jmeter/resultados.jtl \
            -e -o jmeter/reporte-html \
            -JHOST=localhost \
            -JPORT=8080 \
            -JPROTOCOL=http

      - name: Guardar reporte JMeter como artefacto
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: reporte-jmeter
          path: |
            jmeter/reporte-html/
            jmeter/resultados.jtl
          retention-days: 30

      - name: Guardar logs como artefacto (en caso de fallo)
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: docker-logs
          path: |
            docker-compose-logs.txt

      - name: Crear archivo de logs para artefacto
        if: failure()
        run: |
          docker compose logs > docker-compose-logs.txt

      - name: Apagar contenedores
        if: always()
        run: docker compose -f docker-compose.yml down

      - name: Create Pull Request from dev to main
        if: github.ref == 'refs/heads/dev' && success()
        uses: repo-sync/pull-request@v2
        with:
          source_branch: dev
          destination_branch: main
          pr_title: "Auto PR: Merge dev to main"
          pr_body: |
            All tests passed successfully!
          github_token: ${{ secrets.PERSONAL_TOKEN }}