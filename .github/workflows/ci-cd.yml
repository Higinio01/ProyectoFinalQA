name: CI/CD Pipeline

on:
  push:
    branches: ["dev", "main"]

permissions:
  contents: write
  actions: read
  checks: write
  pull-requests: write

jobs:
  build-test:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'

    services:
      db_test:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: admin
          POSTGRES_DB: inventario_db_test
        ports:
          - 5433:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      SPRING_PROFILES_ACTIVE: test
      SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5433/inventario_db_test
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: admin
      APPLICATION_SECURITY_JWT_SECRET_KEY: 404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Make gradlew executable
        run: chmod +x gradlew

      - name: Wait for PostgreSQL (db_test)
        run: |
          until pg_isready -h localhost -p 5433 -U postgres; do
            echo "Esperando a db_test..."
            sleep 2
          done

      - name: Run Flyway migrations (test)
        run: ./gradlew flywayMigrate -PflywayUrl=jdbc:postgresql://localhost:5433/inventario_db_test -PflywayUser=postgres -PflywayPassword=admin

      - name: Build application
        run: ./gradlew clean build -x test

      - name: Run Technical Regression (Fast)
        run: ./gradlew regressionTest

      - name: Run User Flows Regression
        run: ./gradlew cucumberTest
        continue-on-error: true

      - name: Guardar reportes JUnit como artefacto
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: reportes-junit
          path: |
            build/reports/tests/regressionTest/index.html
            build/reports/tests/unitTest/index.html
          retention-days: 30

      - name: Guardar reportes Cucumber como artefacto
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: reportes-cucumber
          path: |
            build/reports/tests/cucumberTest/index.html
            build/reports/cucumber-report.html
          retention-days: 30

      - name: Guardar logs de pruebas (en caso de fallo)
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: logs-pruebas
          path: |
            build/reports/
            *.log

  stress-test:
    runs-on: ubuntu-latest
    needs: build-test
    if: github.ref == 'refs/heads/dev'

    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4

      - name: Descargar y configurar JMeter
        run: |
          wget https://downloads.apache.org/jmeter/binaries/apache-jmeter-5.6.3.tgz
          tar -xzf apache-jmeter-5.6.3.tgz

      - name: Iniciar servicios con Docker Compose
        run: |
          docker compose -f docker-compose.yml up -d

      - name: Verificar estado de contenedores
        run: |
          echo "=== Estado de contenedores ==="
          docker compose ps
          echo ""
          echo "=== Logs de la base de datos ==="
          docker compose logs db
          echo ""
          echo "=== Logs de la aplicaci√≥n ==="
          docker compose logs app

      - name: Esperar y verificar conectividad
        run: |
          echo "Esperando a que la app est√© disponible..."
          
          # Verificar que la BD est√© lista
          echo "Verificando PostgreSQL..."
          for i in {1..30}; do
            if docker compose exec -T db pg_isready -U postgres; then
              echo "PostgreSQL est√° listo"
              break
            fi
            echo "Esperando PostgreSQL... Intento $i de 30"
            sleep 5
          done
          
          # Dar tiempo adicional para que la app se conecte a la BD
          echo "Dando tiempo para que la app se conecte a la BD..."
          sleep 30
          
          # Verificar logs de la aplicaci√≥n nuevamente
          echo "=== Logs recientes de la aplicaci√≥n ==="
          docker compose logs --tail=50 app
          
          # Intentar conectarse a la aplicaci√≥n
          for i in {1..60}; do
            echo "Intento $i de 60 - Verificando aplicaci√≥n..."
          
            # Primero verificar que el contenedor est√© corriendo
            if ! docker compose ps app | grep -q "Up"; then
              echo "El contenedor de la aplicaci√≥n no est√° corriendo"
              docker compose logs app
              exit 1
            fi
          
            # Verificar conectividad b√°sica al puerto
            if nc -z localhost 8080; then
              echo "Puerto 8080 est√° abierto"
          
              # Intentar el endpoint de login
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:8080/api/auth/login \
                -H "Content-Type: application/json" \
                -d '{"email": "admin@example.com", "password": "admin"}' || echo "000")
          
              echo "C√≥digo de respuesta del login: $HTTP_CODE"
          
              if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "400" ] || [ "$HTTP_CODE" = "401" ]; then
                echo "Aplicaci√≥n est√° respondiendo"
                break
              fi
            else
              echo "Puerto 8080 no est√° disponible"
            fi
          
            if [ $i -eq 60 ]; then
              echo "La aplicaci√≥n no respondi√≥ despu√©s de 10 minutos"
              echo "=== Logs finales de la aplicaci√≥n ==="
              docker compose logs app
              echo "=== Estado final de contenedores ==="
              docker compose ps
              exit 1
            fi
          
            sleep 10
          done

      - name: Crear archivo CSV para pruebas de seguridad
        run: |
          cat > jmeter/login_payloads.csv << 'EOF'
          email_payload,description
          admin@test.com' OR '1'='1' --,Bypass password
          ' UNION SELECT email FROM usuarios --,Extract emails
          admin@test.com'; DROP TABLE usuarios; --,Drop table test
          ' OR id_rol=1 --,Target admin role
          test@test.com'/*,Comment injection
          EOF

      - name: Ejecutar prueba de estr√©s con JMeter
        run: |
          mkdir -p jmeter/reporte-html
          apache-jmeter-5.6.3/bin/jmeter \
            -n \
            -t jmeter/Inventario_testplan.jmx \
            -l jmeter/resultados.jtl \
            -e -o jmeter/reporte-html \
            -JHOST=localhost \
            -JPORT=8080 \
            -JPROTOCOL=http

      - name: Ejecutar pruebas de seguridad con JMeter
        run: |
          mkdir -p jmeter/reporte-seguridad
          apache-jmeter-5.6.3/bin/jmeter \
            -n \
            -t jmeter/Inventario_securityTest.jmx \
            -l jmeter/resultados-seguridad.jtl \
            -e -o jmeter/reporte-seguridad \
            -JHOST=localhost \
            -JPORT=8080 \
            -JPROTOCOL=http

      - name: Guardar reporte JMeter como artefacto
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: reporte-jmeter
          path: |
            jmeter/reporte-html/
            jmeter/resultados.jtl
          retention-days: 30

      - name: Guardar reporte de seguridad como artefacto
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: reporte-seguridad
          path: |
            jmeter/reporte-seguridad/
            jmeter/resultados-seguridad.jtl
          retention-days: 30

      - name: Guardar logs como artefacto (en caso de fallo)
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: docker-logs
          path: |
            docker-compose-logs.txt

      - name: Crear archivo de logs para artefacto
        if: failure()
        run: |
          docker compose logs > docker-compose-logs.txt

      - name: Apagar contenedores
        if: always()
        run: docker compose -f docker-compose.yml down

      - name: Create Pull Request from dev to main
        if: github.ref == 'refs/heads/dev' && success()
        uses: repo-sync/pull-request@v2
        with:
          source_branch: dev
          destination_branch: main
          pr_title: "Auto PR: Merge dev to main"
          pr_body: |
            All tests passed successfully!
            
            üìä Tests ejecutados:
            - ‚úÖ Technical Regression Tests
            - ‚úÖ User Flows Regression (Cucumber)
            - ‚úÖ Stress Tests (JMeter)
            - ‚úÖ Security Tests (SQL Injection + JWT Brute Force)
          github_token: ${{ secrets.PERSONAL_TOKEN }}

  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build & Push Backend Image
        run: |
          docker build -t higinio01/backend-qa:latest .
          docker push higinio01/backend-qa:latest

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e  # Salir si alg√∫n comando falla

            if [ -d "ProyectoFinalQA" ]; then
              cd ProyectoFinalQA

              echo "üõë Deteniendo solo aplicaciones (preservando DB)..."
              docker-compose stop app vue-app
              docker-compose rm -f app vue-app

              echo "üîÑ Actualizando c√≥digo..."
              git pull origin main
            else
              echo "üì• Clonando repositorio..."
              git clone --branch main https://github.com/Higinio01/ProyectoFinalQA.git ProyectoFinalQA
              cd ProyectoFinalQA

              echo "üóÑÔ∏è Iniciando base de datos (primera vez)..."
              docker-compose up -d db

              # Esperar a que la base de datos est√© lista
              echo "‚è≥ Esperando a que PostgreSQL est√© listo..."
              for i in {1..30}; do
                if docker-compose exec -T db pg_isready -U postgres; then
                  echo "‚úÖ PostgreSQL est√° listo"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "‚ùå PostgreSQL no respondi√≥ despu√©s de 5 minutos"
                  docker-compose logs db
                  exit 1
                fi
                echo "‚è≥ Esperando PostgreSQL... intento $i/30"
                sleep 10
              done
            fi

            echo "üì¶ Descargando im√°genes actualizadas..."
            docker-compose pull app vue-app

            echo "üßπ Limpiando contenedores hu√©rfanos (solo apps)..."
            docker container prune -f

            echo "üöÄ Iniciando aplicaciones actualizadas..."
            docker-compose up -d app vue-app

            echo "‚è≥ Verificando que la aplicaci√≥n est√© funcionando..."
            sleep 30
            for i in {1..12}; do
              # Verifica si el puerto est√° abierto
              if nc -z localhost 8080; then
                echo "‚úÖ Aplicaci√≥n est√° respondiendo en puerto 8080"
                break
              fi
              if [ $i -eq 12 ]; then
                echo "‚ùå La aplicaci√≥n no respondi√≥ despu√©s de 2 minutos"
                echo "üìã Logs de la aplicaci√≥n:"
                docker-compose logs --tail=50 app
                echo "üìã Estado de contenedores:"
                docker-compose ps
                exit 1
              fi
              echo "‚è≥ Esperando aplicaci√≥n... intento $i/12"
              sleep 10
            done

            echo "üìä Estado final de los contenedores:"
            docker-compose ps

            echo "üéâ Deploy completado exitosamente!"